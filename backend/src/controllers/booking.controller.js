const { Booking: Booking_Ctrl, BookingSeat: BS_Ctrl, Show: Show_Ctrl_Booking, Movie: Movie_Ctrl_Booking, Theater: Theater_Ctrl_Booking } = require('../models');
const { Op: Op_Booking } = require('sequelize');
exports.startBookingCleanupJob = () => { setInterval(async () => { try { await Booking_Ctrl.destroy({ where: { status: 'pending', expires_at: { [Op_Booking.lt]: new Date() } } }); } catch (error) {} }, 60000); };
exports.startBooking = async (req, res) => { const { show_id, seats } = req.body; const user_id = req.userId; try { const show = await Show_Ctrl_Booking.findByPk(show_id); if (!show) return res.status(404).send({ message: "Show not found." }); const existingBookings = await Booking_Ctrl.findAll({ where: { show_id, status: { [Op_Booking.ne]: 'cancelled' }, expires_at: { [Op_Booking.or]: { [Op_Booking.gt]: new Date(), [Op_Booking.is]: null } } }, include: [BS_Ctrl] }); const bookedSeats = existingBookings.flatMap(b => b.BookingSeats.map(bs => bs.seat_identifier)); const alreadyBooked = seats.some(seat => bookedSeats.includes(seat)); if (alreadyBooked) { return res.status(409).send({ message: "One or more selected seats are already taken." }); } const booking = await Booking_Ctrl.create({ user_id, show_id, status: 'pending', expires_at: new Date(Date.now() + 5 * 60 * 1000) }); const seatData = seats.map(seat_identifier => ({ booking_id: booking.booking_id, seat_identifier })); await BS_Ctrl.bulkCreate(seatData); res.status(201).send({ message: "Booking initiated. You have 5 minutes to confirm.", bookingId: booking.booking_id, expiresAt: booking.expires_at }); } catch (error) { res.status(500).send({ message: error.message }); } };
exports.confirmBooking = async (req, res) => { const { booking_id } = req.body; const user_id = req.userId; try { const booking = await Booking_Ctrl.findOne({ where: { booking_id, user_id } }); if (!booking) return res.status(404).send({ message: "Booking not found." }); if (booking.status !== 'pending') { return res.status(400).send({ message: "This booking cannot be confirmed." }); } if (booking.expires_at < new Date()) { return res.status(400).send({ message: "Booking session has expired." }); } const show = await Show_Ctrl_Booking.findByPk(booking.show_id); const seats = await BS_Ctrl.findAll({ where: { booking_id } }); const total_amount = seats.length * show.base_price; booking.status = 'confirmed'; booking.expires_at = null; booking.total_amount = total_amount; await booking.save(); res.status(200).send({ message: "Booking confirmed successfully!", bookingDetails: booking }); } catch (error) { res.status(500).send({ message: error.message }); } };
exports.getBookingHistory = async (req, res) => { const user_id = req.userId; try { const bookings = await Booking_Ctrl.findAll({ where: { user_id, status: 'confirmed' }, include: [{ model: Show_Ctrl_Booking, include: [{ model: Movie_Ctrl_Booking }, { model: Theater_Ctrl_Booking }] }, { model: BS_Ctrl, attributes: ['seat_identifier'] }], order: [['createdAt', 'DESC']] }); res.status(200).send(bookings); } catch (error) { res.status(500).send({ message: error.message }); } };
